// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/core/SSLVault.sol";
import "../src/mocks/MockBondToken.sol";
import "../src/mocks/MockUSDC.sol";
import "../src/interfaces/ISSLVault.sol";

/**
 * @title SSLVaultTest
 * @notice End-to-end test for the Stealth Settlement Layer
 * @dev Simulates the full flow:
 *      World ID verification (off-chain) → fund vault → CRE matches orders →
 *      CRE generates stealth addresses → settle to stealth addresses
 */
contract SSLVaultTest is Test {
    // ── Contracts ──
    StealthSettlementVault public vault;
    MockBondToken public bondToken;
    MockUSDC public usdc;

    // ── Actors ──
    address public creSigner = makeAddr("creSigner");
    address public funder = makeAddr("funder");

    // Stealth addresses (one-time addresses generated by CRE per trade)
    address public stealthBuyer = makeAddr("stealthBuyer");
    address public stealthSeller = makeAddr("stealthSeller");

    // ── Constants ──
    uint256 public constant BOND_AMOUNT = 10_000e18; // 10,000 bonds
    uint256 public constant USDC_AMOUNT = 1_005_000e6; // 1,005,000 USDC

    function setUp() public {
        // 1. Deploy vault with CRE signer
        vault = new StealthSettlementVault(creSigner);

        // 2. Deploy mock tokens
        bondToken = new MockBondToken();
        usdc = new MockUSDC();

        // 3. Mint tokens to funder and fund the vault
        bondToken.mint(funder, BOND_AMOUNT);
        usdc.mint(funder, USDC_AMOUNT);

        vm.startPrank(funder);
        bondToken.approve(address(vault), BOND_AMOUNT);
        usdc.approve(address(vault), USDC_AMOUNT);
        vault.fund(address(bondToken), BOND_AMOUNT);
        vault.fund(address(usdc), USDC_AMOUNT);
        vm.stopPrank();
    }

    // ──────────────────────────────────────────────
    //  Fund Tests
    // ──────────────────────────────────────────────

    function test_Fund() public view {
        assertEq(bondToken.balanceOf(address(vault)), BOND_AMOUNT);
        assertEq(usdc.balanceOf(address(vault)), USDC_AMOUNT);
    }

    function test_RevertFundZeroAmount() public {
        vm.expectRevert("SSL: zero amount");
        vault.fund(address(bondToken), 0);
    }

    // ──────────────────────────────────────────────
    //  Settlement Tests
    // ──────────────────────────────────────────────

    function test_Settle() public {
        bytes32 orderId = keccak256("order_1");

        // CRE triggers settlement to stealth addresses
        vm.prank(creSigner);
        vault.settle(
            orderId,
            stealthBuyer,
            stealthSeller,
            address(bondToken), // tokenA: bonds go to seller
            address(usdc), // tokenB: USDC goes to buyer
            BOND_AMOUNT,
            USDC_AMOUNT
        );

        // Verify tokens arrived at stealth addresses
        assertEq(bondToken.balanceOf(stealthSeller), BOND_AMOUNT);
        assertEq(usdc.balanceOf(stealthBuyer), USDC_AMOUNT);

        // Verify order marked as settled
        assertTrue(vault.settledOrders(orderId));
    }

    function test_SettleEmitsEvent() public {
        bytes32 orderId = keccak256("order_event");

        vm.expectEmit(true, false, false, true);
        emit ISSLVault.Settled(orderId, stealthBuyer, stealthSeller);

        vm.prank(creSigner);
        vault.settle(
            orderId,
            stealthBuyer,
            stealthSeller,
            address(bondToken),
            address(usdc),
            BOND_AMOUNT,
            USDC_AMOUNT
        );
    }

    function test_RevertSettleNotCRE() public {
        bytes32 orderId = keccak256("order_unauthorized");
        address attacker = makeAddr("attacker");

        vm.prank(attacker);
        vm.expectRevert("not CRE");
        vault.settle(
            orderId,
            stealthBuyer,
            stealthSeller,
            address(bondToken),
            address(usdc),
            BOND_AMOUNT,
            USDC_AMOUNT
        );
    }

    function test_RevertSettleAlreadySettled() public {
        bytes32 orderId = keccak256("order_duplicate");

        // First settlement succeeds
        vm.prank(creSigner);
        vault.settle(
            orderId,
            stealthBuyer,
            stealthSeller,
            address(bondToken),
            address(usdc),
            BOND_AMOUNT,
            USDC_AMOUNT
        );

        // Fund vault again for second attempt
        bondToken.mint(funder, BOND_AMOUNT);
        usdc.mint(funder, USDC_AMOUNT);
        vm.startPrank(funder);
        bondToken.approve(address(vault), BOND_AMOUNT);
        usdc.approve(address(vault), USDC_AMOUNT);
        vault.fund(address(bondToken), BOND_AMOUNT);
        vault.fund(address(usdc), USDC_AMOUNT);
        vm.stopPrank();

        // Second settlement with same orderId reverts
        vm.prank(creSigner);
        vm.expectRevert("settled");
        vault.settle(
            orderId,
            stealthBuyer,
            stealthSeller,
            address(bondToken),
            address(usdc),
            BOND_AMOUNT,
            USDC_AMOUNT
        );
    }

    // ──────────────────────────────────────────────
    //  Full Stealth Settlement Scenario
    // ──────────────────────────────────────────────

    function test_FullStealthSettlementFlow() public {
        // ═══════════════════════════════════════════
        // Full demo flow:
        //   1. World ID verification (happens off-chain in CRE)
        //   2. Users submit encrypted orders to CRE
        //   3. CRE matches counterparties confidentially
        //   4. CRE generates stealth addresses
        //   5. CRE triggers on-chain settlement
        //   6. Funds arrive at stealth addresses
        //   7. Users withdraw using stealth private keys
        // ═══════════════════════════════════════════

        // Simulate two separate trades with unique stealth addresses each time

        // ── Trade 1 ──
        bytes32 orderId1 = keccak256("trade_1");
        address stealth1Buyer = makeAddr("stealth1Buyer");
        address stealth1Seller = makeAddr("stealth1Seller");

        uint256 trade1Bonds = 5_000e18;
        uint256 trade1Usdc = 502_500e6;

        vm.prank(creSigner);
        vault.settle(
            orderId1,
            stealth1Buyer,
            stealth1Seller,
            address(bondToken),
            address(usdc),
            trade1Bonds,
            trade1Usdc
        );

        // Verify trade 1 — funds at stealth addresses
        assertEq(bondToken.balanceOf(stealth1Seller), trade1Bonds);
        assertEq(usdc.balanceOf(stealth1Buyer), trade1Usdc);
        assertTrue(vault.settledOrders(orderId1));

        // ── Trade 2 ── (remaining vault balance)
        bytes32 orderId2 = keccak256("trade_2");
        address stealth2Buyer = makeAddr("stealth2Buyer");
        address stealth2Seller = makeAddr("stealth2Seller");

        uint256 trade2Bonds = 5_000e18;
        uint256 trade2Usdc = 502_500e6;

        vm.prank(creSigner);
        vault.settle(
            orderId2,
            stealth2Buyer,
            stealth2Seller,
            address(bondToken),
            address(usdc),
            trade2Bonds,
            trade2Usdc
        );

        // Verify trade 2
        assertEq(bondToken.balanceOf(stealth2Seller), trade2Bonds);
        assertEq(usdc.balanceOf(stealth2Buyer), trade2Usdc);
        assertTrue(vault.settledOrders(orderId2));

        // On-chain view: vault sent funds to random-looking addresses
        // No visible counterparty link between any stealth addresses
        assertEq(bondToken.balanceOf(address(vault)), 0);
        assertEq(usdc.balanceOf(address(vault)), 0);
    }
}
